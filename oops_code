Â                              OOPS
topic:class & object

problem 1(include->this,instance,constructor,parameter,method)


// Blueprint class for Student
class Student {
Â    String name; // variable to store student's name
Â    int rn;      // variable to store student's roll number

Â    // Constructor: called when we create a new Student object
Â    Student(String name, int rn) {
Â        this.name = name; // "this.name" means class variable, "name" is the parameter
Â        this.rn = rn;     // assigning constructor parameter to class variable
Â    }

Â    // Method to display student information
Â    void displayInfo() {
Â        System.out.println("name : " + name);       // prints student name
Â        System.out.println("rollnumber : " + rn);   // prints roll number
Â    }
}

// Main class that contains the entry point of the program
public class Demo {
Â    public static void main(String[] args) {
Â        // Creating two Student objects using constructor
Â        Student s1 = new Student("priya", 18);   // object s1 with name "priya" and roll number 18
Â        Student s2 = new Student("sakthi", 19); // object s2 with name "sakthi" and roll number 19

Â        // Calling method to display info of s1
Â        s1.displayInfo();

Â        System.out.println(); // prints a blank line

Â        // Calling method to display info of s2
Â        s2.displayInfo();
Â    }
}

output:

name : priya
rollnumber : 18

name : sakthi
rollnumber : 19
-------------------------------------------------------------------------------------------------------------------------------------problem 2 (without this)

class Student{
Â    String name;
Â    int rn;

Â    void displayInfo(){
Â        System.out.println("name : " +name);
Â        System.out.println("rollnumber : " +rn);
Â    }
}
Â    public class demo{
Â        public static void main(String[] args){
Â            Student s1 = new Student();
Â            Student s2 = new Student();
Â            s1.name = "sakthi";
Â            s1.rn = 19;

Â            s1.displayInfo();
Â            System.out.println();
Â            s2.displayInfo();
Â        }
Â    }



output:
name : sakthi
rollnumber : 19

name : null
rollnumber : 0
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------problem 3(using operator)

class Stud{
Â    int a;
Â    int b;
Â    int c;
Â    void display(){
Â        System.out.println("the sum is : " +c);
Â    }
}
Â    public class Sums{
Â        public static void main(String[] args){
Â            Stud s1 = new Stud();
Â            s1.a = 23;
Â            s1.b = 19;
Â            s1.c = s1.a + s1.b;
Â            s1.display();
Â        }
Â    }
output:

the sum is : 42
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------problem 4(static method)

class account{
Â    String accountHolderName;
Â    int balance;
Â    static int accountCount = 0;
//constructor
Â    account(String accountHolderName,int balance){
Â        this.accountHolderName = accountHolderName;
Â        this.balance = balance;
Â        accountCount++;
Â    }
Â // Instance method to display account details
Â     void displayAccount() {
Â        System.out.println("Account Holder: " + accountHolderName + ", Balance: " + balance);
Â    }

Â     // Static method to show total accounts
Â    static void showTotalAccount(){
Â        System.out.println("Total accounts : " +accountCount);
Â    }
}
//main class
Â    public class bank{
Â        public static void main(String[] args){
Â            account a1 = new account("sakthi",7000);
Â            account a2 = new account("priya",6000);
Â            account a3 = new account("kutty",3445);

Â            a1.displayAccount();
Â            a2.displayAccount();
Â            a3.displayAccount();

Â           account.showTotalAccount();

Â        }
Â    }
output:

Account Holder: sakthi, Balance: 7000
Account Holder: priya, Balance: 6000
Account Holder: kutty, Balance: 3445
Total accounts : 3
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------problem 5(INHERITANCE--with constructor)

class A{
Â    A(){System.out.println("parent");}
}

class B extends A{
Â    B() { System.out.println("child");}
}

public class Test{
Â    public static void main(String[] args){
Â        B obj = new B();
Â    }
}

output:
parent
child
---
Problem 6: Basic Inheritance
// Parent class
class Parent {
Â    void show() {
Â        System.out.println("This is Parent class");
Â    }
}

// Child class
class Child extends Parent {
Â    void display() {
Â        System.out.println("This is Child class");
Â    }
}

// Main class
public class Example {
Â    public static void main(String[] args) {
Â        Child obj = new Child();
Â        obj.show();     // from Parent
Â        obj.display();  // from Child
Â    }
}


Output:

This is Parent class
This is Child class
---
Problem 7: super() and method overriding
// Parent class
class Animal {

Â    // Constructor of Animal class
Â    Animal() {
Â        System.out.println("Animal created");
Â    }

Â    // Method of Animal class
Â    void sound() {
Â        System.out.println("Animal makes sound");
Â    }
}

// Child class
class Dog extends Animal {

Â    // Constructor of Dog class
Â    Dog() {
Â        super(); // Calls Animal() constructor first
Â        System.out.println("Dog created");
Â    }

Â    // Method of Dog class
Â    void sound() {
Â        super.sound(); // Calls Animal's sound() first
Â        System.out.println("Dog barks");
Â    }
}

// Main class
public class Demo {
Â    public static void main(String[] args) {
Â        Dog d = new Dog();   // Dog constructor runs (Animal â†’ Dog)
Â        d.sound();           // sound() runs (Animal â†’ Dog)
Â    }
}


Output:

Animal created
Dog created
Animal makes sound
Dog barks
---
Problem 8: this, super, and constructor chaining
// Parent class
class Vehicle {
Â    int speed;

Â    Vehicle(int speed) {
Â        this.speed = speed;
Â        System.out.println("Vehicle speed set is " + this.speed);
Â    }

Â    void display() {
Â        System.out.println("Vehicle speed is " + speed);
Â    }
}

// Child class
class Car extends Vehicle {
Â    String model;

Â    Car(int speed, String model) {
Â        super(speed);      // Calls Vehicle constructor
Â        this.model = model;
Â        System.out.println("Car model is " + this.model);
Â    }

Â    void show() {
Â        super.display();   // Calls Vehicle's display()
Â        System.out.println("Details are displayed");
Â    }
}

// Main class
public class DemoCar {
Â    public static void main(String[] args) {
Â        Car obj = new Car(120, "BMW");
Â        obj.show();
Â    }
}


Output:

Vehicle speed set is 120
Car model is BMW
Vehicle speed is 120
Details are displayed
---
problem 9 (multilevel inheritance)
// Parent class
class person {
Â    // Constructor of Person class
Â    person() {
Â        System.out.println("person is created");  // Prints when Person constructor is called
Â    }

Â    // Method of Person class
Â    void info() {
Â        System.out.println("this is person");  // Prints when info() is called
Â    }
}

// Child class of Person
class employee extends person {
Â    // Constructor of Employee class
Â    employee() {
Â        // Java automatically calls super() here if not written
Â        // So Person constructor is called first, then Employee constructor
Â        System.out.println("employee is created");  // Prints when Employee constructor runs
Â    }

Â    // Method of Employee class
Â    void work() {
Â        System.out.println("employee is working");  // Prints when work() is called
Â    }
}

// Child class of Employee (Multilevel Inheritance)
class manager extends employee {
Â    // Constructor of Manager class
Â    manager() {
Â        super();  // Calls Employee constructor (which also calls Person constructor automatically)
Â        System.out.println("manager is created");  // Prints when Manager constructor runs
Â    }

Â    // Method of Manager class
Â    void manage() {
Â        super.work();  // Calls Employee's work() method
Â        System.out.println("manager is managing");  // Prints after calling parent work()
Â    }
}
// Main class
public class demo {
Â    public static void main(String[] args) {
Â        // Create an object of Manager
Â        manager obj = new manager();
Â        // Flow of constructor calls:
Â        // 1. Person() -> prints "person is created"
Â        // 2. Employee() -> prints "employee is created"
Â        // 3. Manager() -> prints "manager is created"
Â        obj.info();  // Prints: "this is person"
Â        obj.work();  // Prints: "employee is working"
Â        obj.manage(); // Then prints "manager is managing"
Â    }
}

output:

person is created
employee is created
manager is created
this is person
employee is working
employee is working
manager is managing
---
problem 10
class vehicle{
Â    int speed;
Â    vehicle(int speed){
Â        this.speed = speed;
Â        System.out.println("vehicle speed set to " +speed);
Â    }

Â    void showspeed(){
Â        System.out.println("vehicle speed is " +speed);
Â    }

}

class car extends vehicle{
Â    String model;
Â    car(String model,int speed){
Â        super(speed);
Â        this.model = model;
Â        System.out.println("car model is " +model);
Â    }

Â    void showcar(){
Â        super.showspeed();
Â        System.out.println("car model:  " +this.model);
Â    }
}

class sportscar extends car{
Â    boolean turbo;
Â    sportscar(String model,int speed,boolean turbo){
Â        super(model,speed);
Â        this.turbo = turbo;
Â        System.out.println("sports car turbo enabled: " +turbo);
Â    }

Â    void showsports(){
Â        super.showcar();
Â        System.out.println("SportsCar details - Model: " + model + " Speed: " + speed + ", Turbo: " + turbo );
Â    }
}

public class Test{
Â    public static void main(String[] args) {
Â        sportscar obj = new sportscar("BMW",120,true);
Â        obj.showsports();
Â    }
}
output:

vehicle speed set to 120
car model is BMW
sports car turbo enabled: true
vehicle speed is 120
car model:  BMW
SportsCar details - Model: BMW Speed: 120, Turbo: true
---

problem 11(hierarchical inheritance)

class Vehicle {
Â    void fuelType() {
Â        System.out.println("This vehicle uses fuel.");
Â    }
}

class Car extends Vehicle {
Â    void wheels() {
Â        System.out.println("Car has 4 wheels.");
Â    }
}

class Bike extends Vehicle {
Â    void wheels() {
Â        System.out.println("Bike has 2 wheels.");
Â    }
}

public class Demo {
Â    public static void main(String[] args) {
Â        Car obj = new Car();
Â        obj.fuelType();  // Inherited from Vehicle
Â        obj.wheels();    // Car's own method

Â        Bike b1 = new Bike();
Â        b1.fuelType();   // Inherited from Vehicle
Â        b1.wheels();     // Bike's own method
Â    }
}

output:
this vehicle uses fuel
Car has 4 wheels
this vehicle uses fuel
Bike has 2 wheels

---

problem 12(hybrid inheritance)
// Parent class
class Vehicle {
Â    void fuelType() {
Â        System.out.println("Vehicle uses fuel.");
Â    }
}

// First child (part of multilevel)
class Car extends Vehicle {
Â    void wheels() {
Â        System.out.println("Car has 4 wheels.");
Â    }
}

// Second child (hierarchical)
class Bike extends Vehicle {
Â    void wheels() {
Â        System.out.println("Bike has 2 wheels.");
Â    }
}

// Multilevel child
class SportsCar extends Car {
Â    void turbo() {
Â        System.out.println("SportsCar has turbo mode.");
Â    }
}

// Main class
public class Demo {
Â    public static void main(String[] args) {
Â        Car c = new Car();
Â        c.fuelType();
Â        c.wheels();

Â        Bike b = new Bike();
Â        b.fuelType();
Â        b.wheels();

Â        SportsCar s = new SportsCar();
Â        s.fuelType();
Â        s.wheels();
Â        s.turbo();
Â    }
}


output:
Vehicle uses fuel.
Car has 4 wheels.
Vehicle uses fuel.
Bike has 2 wheels.
Vehicle uses fuel.
Car has 4 wheels.
SportsCar has turbo mode.

---
ðŸ”¹ What is a Constructor?

1.A special method used to initialize objects of a class.

2.It runs automatically when an object is created.

3.Name of the constructor = Name of the class

4.No return type, not even void.
---
ðŸ”¹ Types of Constructors

1.Default Constructor

No parameters

Java provides it automatically if you donâ€™t define any constructor
---
class Demo {
Â    Demo() {  // default constructor
Â        System.out.println("Object is created");
Â    }
}

public class Test {
Â    public static void main(String[] args) {
Â        Demo d = new Demo();  // prints "Object is created"
Â    }
}
---
2.Parameterized Constructor

Takes arguments to initialize object with specific values

class Demo {
Â    int x;
Â    Demo(int value) {   // parameterized constructor
Â        x = value;
Â        System.out.println("Value = " + x);
Â    }
}

public class Test {
Â    public static void main(String[] args) {
Â        Demo d = new Demo(10);  // prints "Value = 10"
Â    }
}

---
3.Constructor Overloading

Multiple constructors in the same class with different parameters

class Demo {
Â    int x, y;

Â    Demo() {  // no-arg constructor
Â        x = 0; y = 0;
Â    }

Â    Demo(int a) {  // one-arg constructor
Â        x = a; y = 0;
Â    }

Â    Demo(int a, int b) {  // two-arg constructor
Â        x = a; y = b;
Â    }

Â    void display() {
Â        System.out.println("x = " + x + ", y = " + y);
Â    }
}

public class Test {
Â    public static void main(String[] args) {
Â        Demo d1 = new Demo();
Â        Demo d2 = new Demo(5);
Â        Demo d3 = new Demo(3, 7);

Â        d1.display();  // x=0, y=0
Â        d2.display();  // x=5, y=0
Â        d3.display();  // x=3, y=7
Â    }
}

ðŸ”¹ Key Points to Remember

1.Constructor name = class name

2.No return type

3.Automatically called when object is created

4.Can be overloaded (same name, different parameters)

5.Can use this() to call another constructor in the same class

6.Can use super() to call parent class constructor (if inheritance exists)
---
problem 14(ENCAPSULATION)

class mobile{
Â    private int price;


public void setprice(int p){
Â    if(p>1000)
Â       price = p;
Â    else
Â       System.out.println("invaild price!!");
}

public int getprice(){
Â    return price;
}
}
public class demo{
Â    public static void main(String[] args) {
Â        mobile obj = new mobile();
Â        obj.setprice(15000);

Â        System.out.println("your price: " +obj.getprice());

Â        obj.setprice(500);
Â    }
}



output:
your price: 15000
invaild price!!
---
problem(ENCAPSULATION)

class product{
Â    private String name;
Â    private int price;
Â    private int quantity;

Â    public void setDetails(String n , int p , int q){
Â        if(p<=0 || q<=0){
Â           System.out.println("invalid price or qantity");
Â       }else {
Â            name = n;
Â            price = p;
Â            quantity = q;
Â        }
Â    }
Â    public void displayDetails(){
Â        System.out.println("Name: " + name);
Â        System.out.println("Price: " + price);
Â        System.out.println("Quantity: " + quantity);
Â    }

Â    public int calculatetotal(){
Â 
Â        return price * quantity;
Â    }

}

public class demo{
Â    public static void main(String[] args) {
Â        product obj = new product();

Â        obj.setDetails("laptop" , 10000 , 2);
Â        obj.displayDetails();
Â        System.out.println("total cost is: " +obj.calculatetotal());

Â        obj.setDetails("Mouse", -500, 3);
Â    }
}
output
Name: laptop
Price: 10000
Quantity: 2
total cost is: 20000
invalid price or qantity
---
abstraction (interface)

problem

interface vehicle{
Â    void move();
}

class bike implements vehicle {
Â    public void move(){
Â    System.out.println("bike moves fast");
}
}

public class demo{
Â    public static void main(String[] args) {
Â        vehicle v1 = new bike();

Â        v1.move();
Â    }
}


output
bike moves fast

---

problem
(abstraction)
// Abstract class
abstract class Employee {
Â    abstract void calculateSalary();  // abstract method

Â    void companyName() {              // normal method
Â        System.out.println("Works at ABC Corp");
Â    }
}

// Concrete class
class Manager extends Employee {
Â    public void calculateSalary() {   // implement abstract method
Â        System.out.println("Manager salary is 50000");
Â    }
}

// Main class
public class Demo {
Â    public static void main(String[] args) {
Â        Employee a1 = new Manager();  // reference of abstract class, object of concrete class
Â        a1.companyName();             // call normal method
Â        a1.calculateSalary();         // call implemented method
Â    }
}


output
Works at ABC Corp
Manager salary is 50000


---
problem(both abstraction and interface)

abstract class employee{
Â    abstract void calculateSalary();


void companyName(){
Â    System.out.println("Works at ABC Corp");
}
}
interface Bonus{
Â    public void calculateBonus();
}


class manager extends employee implements Bonus{
Â    public void calculateSalary(){
Â        System.out.println("Manager salary is 50000");
Â    }

Â    public void calculateBonus(){
Â        System.out.println("manager bonus is 10000");
Â    }
}
Â 
public class demo{
Â    public static void main(String[] args) {
Â        employee a1 = new manager();
Â        a1.companyName();
Â        a1.calculateSalary();
Â        Bonus b1 = new manager();
Â        b1.calculateBonus();
Â    }
}
Â output
Works at ABC Corp
Manager salary is 50000
manager bonus is 10000
---
problem              Polymorphism (compile time-static method)

class Calculator{
Â        int multiply(int a,int b) {
Â            return a*b;
Â        }
Â        int multiply(int a, int b, int c) {
Â            return a*b*c;
Â        }

Â    }
Â    public class demo{
Â        public static void main(String[] args) {
Â            Calculator c1 = new Calculator();
Â            System.out.println(c1.multiply(13,12));
Â            System.out.println(c1.multiply(12, 12, 12));
Â        }
Â    }

output
156
1728
---
problem                                                                  (run time-dynamic--overriding)
class Animal{
Â    void sound(){
Â        System.out.println("animal makes sound");
Â    }
}
class Cat extends Animal {
Â    void sound(){
Â        System.out.println("Cats meow");
Â    }
}

public class demo{
Â    public static void main(String[] args) {
Â        Animal a1 = new Animal();
Â        a1.sound();

Â        Animal b1 = new Cat();
Â        b1.sound();

Â    }
}

output
animal makes sound
Cats meow
---
problem

output
